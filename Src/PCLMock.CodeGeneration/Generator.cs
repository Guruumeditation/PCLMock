namespace PCLMock.CodeGeneration
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Threading.Tasks;
    using Logging;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Editing;
    using Microsoft.CodeAnalysis.MSBuild;

    public static class Generator
    {
        private static readonly Type logSource = typeof(Generator);

        private const string headerComment =
@"-----------------------------------------------------------------------
<autogenerated>
   This code was generated from a template.

   Changes to this file may cause incorrect behaviour and will be lost
   if the code is regenerated.
</autogenerated>
------------------------------------------------------------------------";

        public async static Task<IImmutableList<SyntaxNode>> GenerateMocksAsync(
            ILogSink logSink,
            Language language,
            string solutionPath,
            Func<INamedTypeSymbol, bool> interfacePredicate,
            Func<INamedTypeSymbol, string> mockNamespaceSelector,
            Func<INamedTypeSymbol, string> mockNameSelector,
            IImmutableList<IPlugin> plugins)
        {
            var workspace = MSBuildWorkspace.Create();
            var solution = await workspace.OpenSolutionAsync(solutionPath);

            return await GenerateMocksAsync(
                logSink,
                language,
                solution,
                interfacePredicate,
                mockNamespaceSelector,
                mockNameSelector,
                plugins);
        }

        public async static Task<IImmutableList<SyntaxNode>> GenerateMocksAsync(
            ILogSink logSink,
            Language language,
            Solution solution,
            Func<INamedTypeSymbol, bool> interfacePredicate,
            Func<INamedTypeSymbol, string> mockNamespaceSelector,
            Func<INamedTypeSymbol, string> mockNameSelector,
            IImmutableList<IPlugin> plugins)
        {
            var syntaxGenerator = SyntaxGenerator.GetGenerator(solution.Workspace, language.ToSyntaxGeneratorLanguageName());
            var compilations = await Task.WhenAll(
                solution
                    .Projects
                    .Select(async project =>
                        {
                            var compilation = await project.GetCompilationAsync();
                            // make sure the compilation has a reference to PCLMock
                            compilation = compilation.AddReferences(MetadataReference.CreateFromFile(typeof(MockBase<>).Assembly.Location));

                            foreach (var plugin in plugins)
                            {
                                compilation = plugin.InitializeCompilation(compilation);
                            }

                            if (logSink.IsEnabled)
                            {
                                logSink.Debug(logSource, "Compilation generated for project '{0}' with references:", project.Name);

                                foreach (var reference in compilation.References)
                                {
                                    logSink.Debug(logSource, "- {0}", reference.Display);
                                }
                            }

                            return compilation;
                        }));

            return compilations
                .SelectMany(
                    compilation =>
                        GetSymbolsRecursive(compilation.SourceModule.GlobalNamespace)
                            .OfType<INamedTypeSymbol>()
                            .Where(typeSymbol => typeSymbol.TypeKind == TypeKind.Interface && !typeSymbol.IsImplicitlyDeclared)
                            .Where(typeSymbol => interfacePredicate == null || interfacePredicate(typeSymbol))
                            .Select(interfaceSymbol => new
                            {
                                InterfaceSymbol = interfaceSymbol,
                                Compilation = compilation
                            }))
                .Select(
                    x =>
                    {
                        var @namespace = mockNamespaceSelector(x.InterfaceSymbol);
                        var name = mockNameSelector(x.InterfaceSymbol);

                        if (logSink.IsEnabled)
                        {
                            logSink.Positive(
                                logSource,
                                "Generating mock for interface '{0}' with namespace '{1}', name '{2}'.",
                                x.InterfaceSymbol,
                                @namespace,
                                name);
                        }

                        var semanticModel = x.Compilation.GetSemanticModel(x.InterfaceSymbol.DeclaringSyntaxReferences.First().SyntaxTree);

                        return GenerateMock(logSink, language, syntaxGenerator, semanticModel, x.InterfaceSymbol, @namespace, name, plugins);
                    })
                .Select((syntaxNode, i) => i == 0 ? syntaxGenerator.WithLeadingComments(syntaxNode, headerComment, language) : syntaxNode)
                .ToImmutableList();
        }

        private static SyntaxNode GenerateMock(
            ILogSink logSink,
            Language language,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            INamedTypeSymbol interfaceSymbol,
            string mockNamespace,
            string mockName,
            IImmutableList<IPlugin> plugins)
        {
            var namespaceSyntax = GetNamespaceDeclarationSyntax(syntaxGenerator, semanticModel, mockNamespace, language);
            var classSyntax = GetClassDeclarationSyntax(syntaxGenerator, semanticModel, mockName, interfaceSymbol);

            classSyntax = syntaxGenerator
                .AddAttributes(classSyntax, GetClassAttributesSyntax(syntaxGenerator, semanticModel));
            classSyntax = syntaxGenerator
                .AddMembers(classSyntax, GetMemberDeclarations(logSink, syntaxGenerator, semanticModel, mockName, interfaceSymbol, language, plugins));
            namespaceSyntax = syntaxGenerator
                .AddMembers(namespaceSyntax, classSyntax);

            return syntaxGenerator
                .CompilationUnit(namespaceSyntax)
                .NormalizeWhitespace();
        }

        private static SyntaxNode GetNamespaceDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            string @namespace,
            Language language)
        {
            return syntaxGenerator.NamespaceDeclaration(@namespace);
        }

        private static SyntaxNode GetClassDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            string name,
            INamedTypeSymbol interfaceSymbol)
        {
            var interfaceType = syntaxGenerator.TypeExpression(interfaceSymbol);
            var mockBaseType = semanticModel
                .Compilation
                .GetTypeByMetadataName("PCLMock.MockBase`1");

            if (mockBaseType == null)
            {
                throw new InvalidOperationException("Failed to find type in PCLMock assembly. Are you sure this project has a reference to PCLMock?");
            }

            var baseType = syntaxGenerator.TypeExpression(
                mockBaseType
                    .Construct(interfaceSymbol));

            var accessibility = interfaceSymbol.DeclaredAccessibility == Accessibility.NotApplicable
                ? Accessibility.Public
                : interfaceSymbol.DeclaredAccessibility;

            var classDeclaration = syntaxGenerator.ClassDeclaration(
                name,
                accessibility: accessibility,
                modifiers: DeclarationModifiers.Partial,
                typeParameters: interfaceSymbol.TypeParameters.Select(x => x.Name),
                baseType: baseType,
                interfaceTypes: new[] { interfaceType });

            // TODO: tidy this up once this issue is rectified: https://github.com/dotnet/roslyn/issues/1658
            foreach (var typeParameter in interfaceSymbol.TypeParameters)
            {
                if (typeParameter.HasConstructorConstraint ||
                    typeParameter.HasReferenceTypeConstraint ||
                    typeParameter.HasValueTypeConstraint ||
                    typeParameter.ConstraintTypes.Length > 0)
                {
                    var kinds = (typeParameter.HasConstructorConstraint ? SpecialTypeConstraintKind.Constructor : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasReferenceTypeConstraint ? SpecialTypeConstraintKind.ReferenceType : SpecialTypeConstraintKind.None) |
                                (typeParameter.HasValueTypeConstraint ? SpecialTypeConstraintKind.ValueType : SpecialTypeConstraintKind.None);

                    classDeclaration = syntaxGenerator.WithTypeConstraint(
                        classDeclaration,
                        typeParameter.Name,
                        kinds: kinds,
                        types: typeParameter.ConstraintTypes.Select(t => syntaxGenerator.TypeExpression(t)));
                }
            }

            return classDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetClassAttributesSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel)
        {
            // GENERATED CODE:
            //
            //     [System.CodeDom.Compiler.GeneratedCode("PCLMock", "[version]")]
            //     [System.Runtime.CompilerServices.CompilerGenerated)]
            yield return syntaxGenerator
                .Attribute(
                    "System.CodeDom.Compiler.GeneratedCode",
                    syntaxGenerator.LiteralExpression("PCLMock"),
                    syntaxGenerator.LiteralExpression(typeof(MockBase<>).Assembly.GetName().Version.ToString()));
            yield return syntaxGenerator
                .Attribute(
                    "System.Runtime.CompilerServices.CompilerGenerated");
        }

        private static SyntaxNode GetConstructorDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            string name)
        {
            // GENERATED CODE:
            //
            //     public Name(MockBehavior behavior = MockBehavior.Strict)
            //         : base(behavior)
            //     {
            //         ConfigureBehaviorGenerated();
            //         ConfigureBehavior();
            //
            //         if (behavior == MockBehavior.Loose)
            //         {
            //             ConfigureLooseBehaviorGenerated();
            //             ConfigureLooseBehavior();
            //         }
            //     }
            var mockBehaviorType = syntaxGenerator
                .TypeExpression(
                    semanticModel
                        .Compilation
                        .GetTypeByMetadataName("PCLMock.MockBehavior"));

            return syntaxGenerator
                .ConstructorDeclaration(
                    name,
                    parameters: new[]
                    {
                        syntaxGenerator
                            .ParameterDeclaration(
                                "behavior",
                                mockBehaviorType,
                                initializer: syntaxGenerator.MemberAccessExpression(mockBehaviorType, "Strict"))
                    },
                    accessibility: Accessibility.Public,
                    baseConstructorArguments: new[] { syntaxGenerator.IdentifierName("behavior") },
                    statements: new[]
                    {
                        syntaxGenerator.InvocationExpression(syntaxGenerator.IdentifierName("ConfigureBehaviorGenerated")),
                        syntaxGenerator.InvocationExpression(syntaxGenerator.IdentifierName("ConfigureBehavior")),
                        syntaxGenerator.IfStatement(
                            syntaxGenerator.ValueEqualsExpression(
                                syntaxGenerator.IdentifierName("behavior"),
                                syntaxGenerator.MemberAccessExpression(mockBehaviorType, "Loose")),
                                new[]
                                {
                                    syntaxGenerator.InvocationExpression(syntaxGenerator.IdentifierName("ConfigureLooseBehaviorGenerated")),
                                    syntaxGenerator.InvocationExpression(syntaxGenerator.IdentifierName("ConfigureLooseBehavior"))
                                })
                    });
        }

        private static SyntaxNode GetConfigureBehaviorGeneratedSyntax(
            ILogSink logSink,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            INamedTypeSymbol interfaceSymbol,
            IImmutableList<IPlugin> plugins)
        {
            // GENERATED CODE:
            //
            //     private void ConfigureBehaviorGenerated()
            //     {
            //         // for each plugin, inject the code it generates
            //     }
            var statements = GetMembersRecursive(interfaceSymbol)
                .SelectMany(symbol => plugins.Select(plugin => plugin.GenerateConfigureBehavior(logSink, syntaxGenerator, semanticModel, symbol)))
                .Where(symbol => symbol != null)
                .ToImmutableList();

            return syntaxGenerator
                .MethodDeclaration(
                    "ConfigureBehaviorGenerated",
                    accessibility: Accessibility.Private,
                    statements: statements);
        }

        private static SyntaxNode GetConfigureLooseBehaviorGeneratedSyntax(
            ILogSink logSink,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            INamedTypeSymbol interfaceSymbol,
            IImmutableList<IPlugin> plugins)
        {
            // GENERATED CODE:
            //
            //     private void ConfigureLooseBehaviorGenerated()
            //     {
            //         // for each plugin, inject the code it generates
            //     }
            var statements = GetMembersRecursive(interfaceSymbol)
                .SelectMany(symbol => plugins.Select(plugin => plugin.GenerateConfigureLooseBehavior(logSink, syntaxGenerator, semanticModel, symbol)))
                .Where(symbol => symbol != null)
                .ToImmutableList();

            return syntaxGenerator
                .MethodDeclaration(
                    "ConfigureLooseBehaviorGenerated",
                    accessibility: Accessibility.Private,
                    statements: statements);
        }

        private static SyntaxNode GetConfigureBehaviorMethodSyntax(
            Language language,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureBehavior();
            return syntaxGenerator.MethodDeclaration(
                "ConfigureBehavior",
                accessibility: language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                modifiers: DeclarationModifiers.Partial);
        }

        private static SyntaxNode GetConfigureLooseBehaviorMethodSyntax(
            Language language,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel)
        {
            // GENERATED CODE:
            //
            //     partial void ConfigureLooseBehavior();
            return syntaxGenerator.MethodDeclaration(
                "ConfigureLooseBehavior",
                accessibility: language == Language.VisualBasic ? Accessibility.Private : Accessibility.NotApplicable,
                modifiers: DeclarationModifiers.Partial);
        }

        private static IEnumerable<SyntaxNode> GetMemberDeclarations(
            ILogSink logSink,
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            string name,
            INamedTypeSymbol interfaceSymbol,
            Language language,
            IImmutableList<IPlugin> plugins)
        {
            return
                new SyntaxNode[]
                {
                    GetConstructorDeclarationSyntax(syntaxGenerator, semanticModel, name),
                    GetConfigureBehaviorGeneratedSyntax(logSink, syntaxGenerator, semanticModel, interfaceSymbol, plugins),
                    GetConfigureLooseBehaviorGeneratedSyntax(logSink, syntaxGenerator, semanticModel, interfaceSymbol, plugins),
                    GetConfigureBehaviorMethodSyntax(language, syntaxGenerator, semanticModel),
                    GetConfigureLooseBehaviorMethodSyntax(language, syntaxGenerator, semanticModel)
                }
                .Concat(
                    GetMembersRecursive(interfaceSymbol)
                        .Select(x => GetMemberDeclarationSyntax(syntaxGenerator, semanticModel, x))
                        .Where(x => x != null)
                        .GroupBy(x => x, SyntaxNodeEqualityComparer.Instance)
                        .Where(group => group.Count() == 1)
                        .SelectMany(group => group)
                        .Select(x => syntaxGenerator.AsPublicInterfaceImplementation(x, syntaxGenerator.TypeExpression(interfaceSymbol))));
        }

        private static IEnumerable<ISymbol> GetMembersRecursive(INamedTypeSymbol interfaceSymbol)
        {
            foreach (var member in interfaceSymbol.GetMembers())
            {
                yield return member;
            }

            foreach (var implementedInterface in interfaceSymbol.Interfaces)
            {
                foreach (var member in GetMembersRecursive(implementedInterface))
                {
                    yield return member;
                }
            }
        }

        private static SyntaxNode GetMemberDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            ISymbol symbol)
        {
            var propertySymbol = symbol as IPropertySymbol;

            if (propertySymbol != null)
            {
                return GetPropertyDeclarationSyntax(syntaxGenerator, semanticModel, propertySymbol);
            }

            var methodSymbol = symbol as IMethodSymbol;

            if (methodSymbol != null)
            {
                return GetMethodDeclarationSyntax(syntaxGenerator, semanticModel, methodSymbol);
            }

            // unsupported symbol type, but we don't error - the user can supplement our code as necessary because it's a partial class
            return null;
        }

        private static SyntaxNode GetPropertyDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            IPropertySymbol propertySymbol)
        {
            var getAccessorStatements = GetPropertyGetAccessorsSyntax(syntaxGenerator, semanticModel, propertySymbol).ToList();
            var setAccessorStatements = GetPropertySetAccessorsSyntax(syntaxGenerator, semanticModel, propertySymbol).ToList();
            var declarationModifiers = DeclarationModifiers.None;

            if (getAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsWriteOnly(true);

                // set-only properties are not currently supported
                return null;
            }

            if (setAccessorStatements.Count == 0)
            {
                declarationModifiers = declarationModifiers.WithIsReadOnly(true);
            }

            if (!propertySymbol.IsIndexer)
            {
                return syntaxGenerator
                    .PropertyDeclaration(
                        propertySymbol.Name,
                        syntaxGenerator.TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
            else
            {
                var parameters = propertySymbol
                    .Parameters
                    .Select(x => syntaxGenerator.ParameterDeclaration(x.Name, syntaxGenerator.TypeExpression(x.Type)))
                    .ToList();

                return syntaxGenerator
                    .IndexerDeclaration(
                        parameters,
                        syntaxGenerator.TypeExpression(propertySymbol.Type),
                        accessibility: Accessibility.Public,
                        modifiers: declarationModifiers,
                        getAccessorStatements: getAccessorStatements,
                        setAccessorStatements: setAccessorStatements);
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertyGetAccessorsSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.GetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x.PropertyName);
                yield return syntaxGenerator
                    .ReturnStatement(
                        syntaxGenerator.InvocationExpression(
                            syntaxGenerator.MemberAccessExpression(
                                syntaxGenerator.ThisExpression(),
                                "Apply"),
                            syntaxGenerator.ValueReturningLambdaExpression(
                                lambdaParameterName,
                                syntaxGenerator.MemberAccessExpression(
                                    syntaxGenerator.IdentifierName(lambdaParameterName),
                                    syntaxGenerator.IdentifierName(propertySymbol.Name)))));
            }
            else
            {
                // GENERATED CODE:
                //
                //     return this.Apply(x => x[first, second]);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => syntaxGenerator.Argument(syntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return syntaxGenerator
                    .ReturnStatement(
                        syntaxGenerator.InvocationExpression(
                            syntaxGenerator.MemberAccessExpression(
                                syntaxGenerator.ThisExpression(),
                                "Apply"),
                            syntaxGenerator.ValueReturningLambdaExpression(
                                lambdaParameterName,
                                syntaxGenerator.ElementAccessExpression(
                                    syntaxGenerator.IdentifierName(lambdaParameterName),
                                    arguments))));
            }
        }

        private static IEnumerable<SyntaxNode> GetPropertySetAccessorsSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            IPropertySymbol propertySymbol)
        {
            if (propertySymbol.SetMethod == null)
            {
                yield break;
            }

            var lambdaParameterName = propertySymbol.GetUniqueName();

            if (!propertySymbol.IsIndexer)
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x.PropertyName, value);
                yield return syntaxGenerator
                    .InvocationExpression(
                        syntaxGenerator.MemberAccessExpression(
                            syntaxGenerator.ThisExpression(),
                            "ApplyPropertySet"),
                        syntaxGenerator.ValueReturningLambdaExpression(
                            lambdaParameterName,
                            syntaxGenerator.MemberAccessExpression(
                                syntaxGenerator.IdentifierName(lambdaParameterName),
                                syntaxGenerator.IdentifierName(propertySymbol.Name))),
                        syntaxGenerator.IdentifierName("value"));
            }
            else
            {
                // GENERATED CODE:
                //
                //     this.ApplyPropertySet(x => x[first, second], value);
                var arguments = propertySymbol
                    .Parameters
                    .Select(x => syntaxGenerator.Argument(syntaxGenerator.IdentifierName(x.Name)))
                    .ToList();

                yield return syntaxGenerator
                    .InvocationExpression(
                        syntaxGenerator.MemberAccessExpression(
                            syntaxGenerator.ThisExpression(),
                            "ApplyPropertySet"),
                        syntaxGenerator.ValueReturningLambdaExpression(
                            lambdaParameterName,
                            syntaxGenerator.ElementAccessExpression(
                                syntaxGenerator.IdentifierName(lambdaParameterName),
                                arguments)),
                        syntaxGenerator.IdentifierName("value"));
            }
        }

        private static SyntaxNode GetMethodDeclarationSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            IMethodSymbol methodSymbol)
        {
            if (methodSymbol.MethodKind != MethodKind.Ordinary)
            {
                return null;
            }

            var methodDeclaration = syntaxGenerator
                .MethodDeclaration(methodSymbol);
            methodDeclaration = syntaxGenerator
                .WithModifiers(
                    methodDeclaration,
                    syntaxGenerator
                        .GetModifiers(methodDeclaration)
                        .WithIsAbstract(false));
            methodDeclaration = syntaxGenerator
                .WithStatements(
                    methodDeclaration,
                    GetMethodStatementsSyntax(syntaxGenerator, semanticModel, methodSymbol));

            var csharpMethodDeclaration = methodDeclaration as MethodDeclarationSyntax;

            if (csharpMethodDeclaration != null)
            {
                // remove trailing semi-colon from the declaration
                methodDeclaration = csharpMethodDeclaration.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.None));
            }

            return methodDeclaration;
        }

        private static IEnumerable<SyntaxNode> GetMethodStatementsSyntax(
            SyntaxGenerator syntaxGenerator,
            SemanticModel semanticModel,
            IMethodSymbol methodSymbol)
        {
            // GENERATED CODE (for every ref or out parameter):
            //
            //     string someOutParameter;
            //     var someRefParameter = default(int);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out)
                {
                    yield return syntaxGenerator
                        .LocalDeclarationStatement(
                            syntaxGenerator.TypeExpression(parameter.Type),
                            methodSymbol.GetNameForParameter(parameter));
                }
                else if (parameter.RefKind == RefKind.Ref)
                {
                    yield return syntaxGenerator
                        .LocalDeclarationStatement(
                            methodSymbol.GetNameForParameter(parameter),
                            initializer: syntaxGenerator.DefaultExpression(syntaxGenerator.TypeExpression(parameter.Type)));
                }
            }

            var arguments = methodSymbol
                .Parameters
                .Select(x =>
                    syntaxGenerator
                        .Argument(
                            x.RefKind,
                            syntaxGenerator.IdentifierName(methodSymbol.GetNameForParameter(x))))
                .ToList();

            var typeArguments = methodSymbol
                .TypeArguments
                .Select(x => syntaxGenerator.TypeExpression(x))
                .ToList();

            var lambdaParameterName = methodSymbol.GetUniqueName();

            var lambdaInvocation = syntaxGenerator
                .MemberAccessExpression(
                    syntaxGenerator.IdentifierName(lambdaParameterName),
                    methodSymbol.Name);

            if (typeArguments.Count > 0)
            {
                lambdaInvocation = syntaxGenerator
                    .WithTypeArguments(
                        lambdaInvocation,
                        typeArguments);
            }

            // GENERATED CODE (for every ref or out parameter):
            //
            //     someOutParameter = this.GetOutParameterValue<string>(x => x.TheMethod(out someOutParameter), parameterIndex: 0);
            //     someRefParameter = this.GetRefParameterValue<int>(x => x.TheMethod(ref someRefParameter), parameterIndex: 0);
            for (var i = 0; i < methodSymbol.Parameters.Length; ++i)
            {
                var parameter = methodSymbol.Parameters[i];

                if (parameter.RefKind == RefKind.Out || parameter.RefKind == RefKind.Ref)
                {
                    var nameOfMethodToCall = parameter.RefKind == RefKind.Out ? "GetOutParameterValue" : "GetRefParameterValue";

                    yield return syntaxGenerator
                        .AssignmentStatement(
                            syntaxGenerator.IdentifierName(parameter.Name),
                            syntaxGenerator
                                .InvocationExpression(
                                    syntaxGenerator.MemberAccessExpression(
                                        syntaxGenerator.ThisExpression(),
                                        syntaxGenerator.GenericName(
                                            nameOfMethodToCall,
                                            typeArguments: syntaxGenerator.TypeExpression(parameter.Type))),
                                            arguments: new[]
                                            {
                                                syntaxGenerator.ValueReturningLambdaExpression(
                                                    lambdaParameterName,
                                                    syntaxGenerator.InvocationExpression(
                                                        lambdaInvocation,
                                                        arguments: arguments)),
                                                    syntaxGenerator.LiteralExpression(i)
                                            }));
                }
            }

            // GENERATED CODE:
            //
            //     [return] this.Apply(x => x.SomeMethod(param1, param2));
            var applyInvocation = syntaxGenerator
                .InvocationExpression(
                    syntaxGenerator.MemberAccessExpression(
                        syntaxGenerator.ThisExpression(),
                        "Apply"),
                    syntaxGenerator.ValueReturningLambdaExpression(
                        lambdaParameterName,
                        syntaxGenerator.InvocationExpression(
                            lambdaInvocation,
                            arguments: arguments)));

            if (!methodSymbol.ReturnsVoid)
            {
                applyInvocation = syntaxGenerator.ReturnStatement(applyInvocation);
            }

            yield return applyInvocation;
        }

        private static IEnumerable<ISymbol> GetSymbolsRecursive(INamespaceSymbol namespaceSymbol)
        {
            // using a heap-based stack here instead of recursive call just to be sure we don't overflow the stack
            var stack = new Stack<INamespaceSymbol>();
            stack.Push(namespaceSymbol);

            while (stack.Count > 0)
            {
                var namespaceSymbolToProcess = stack.Pop();

                yield return namespaceSymbolToProcess;

                foreach (var namespaceMember in namespaceSymbolToProcess.GetMembers())
                {
                    var namespaceMemberAsNamespace = namespaceMember as INamespaceSymbol;

                    if (namespaceMemberAsNamespace != null)
                    {
                        stack.Push(namespaceMemberAsNamespace);
                    }
                    else
                    {
                        yield return namespaceMember;
                    }
                }
            }
        }

        private sealed class SyntaxNodeEqualityComparer : IEqualityComparer<SyntaxNode>
        {
            public static readonly SyntaxNodeEqualityComparer Instance = new SyntaxNodeEqualityComparer();

            private SyntaxNodeEqualityComparer()
            {
            }

            public bool Equals(SyntaxNode x, SyntaxNode y) =>
                x.IsEquivalentTo(y, topLevel: true);

            // We have to ensure like syntax nodes have the same hash code in order for Equals to even be called
            // Unfortunately, Roslyn does not implement GetHashCode, so we can't use that. We also don't want to
            // use ToString because then we may as well have just grouped by it and because it includes the
            // implementation, not just the declaration. To do this "properly", we'd have to write a recursive
            // hash code calculator, using similar logic to what IsEquivalentTo gives us.
            public int GetHashCode(SyntaxNode obj) =>
                0;
        }
    }
}